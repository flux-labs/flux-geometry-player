<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Flux: Geometry Player</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.2/jquery.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.1.8/semantic.css">
    <link rel="stylesheet" type="text/css" href="css/jquery.minicolors.css">
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.1.8/semantic.min.js"></script>
    <script src="js/flux-viewport/lib/three.min.js"></script>
    <script src="js/flux-viewport/lib/flux-three-plugins.global.js"></script>
    <script src="js/flux-viewport/build/flux-viewport.global.js"></script>
    <script src="js/CCapture.all.min.js"></script>
    <script src="js/jquery.minicolors.min.js"></script>
    <script src="js/config.js"></script>
    <script src="js/flux-sdk.js"></script>
    <script src="js/flux-sdk-helpers.js"></script>
    <script src="js/player.js"></script>
    <script src="js/index.js"></script>
  </head>
  <body>

    <!-- CONTAINER -->

    <div id='container' class="ui container">
      <div id='header'>
        <h1>FLUX</h1>
        <h2>Geometry Player</h2>
      </div>
      <div id="controls">
        <div class="row" id="description">Visualize your geometries over time.</div>
        <div class="row" id="geometries">
          <div class="ui styled fluid accordion">
            <div class="title title-master">
              <div class="label">
                <i class="dropdown icon"></i> MASTER
              </div>
              <div class="buttons">
                <i class="backward icon" data-content="reset"></i>
                <i class="play icon" data-content="play all"></i>
                <i class="stop icon" data-content="stop all"></i>
                <i class="record icon" data-content="record video"></i>
                <i class="repeat icon" data-content="rotate"></i>
              </div>
            </div>
            <div class="content content-master">
              <div class="row">
                <span class="label">Frame</span>
                <input class="frame" type="range" value="0" min="0" max="1" step="0.001"></input>
              </div>
              <div class="row">
                <span class="label">Speed</span>
                <input class="speed" type="range" value="0.5" min="0" max="1" step="0.001"></input>
              </div>
            </div>
          </div>
        </div>
        <div class="row" id="login">
          <button class="ui huge button">Log in to Flux</button>
        </div>

        <div class="row" id="add">
          <div class="ui huge selection dropdown" id="projects">
            <input type="hidden" name="project"></input>
            <i class="dropdown icon"></i>
            <div class="default text">Select a project</div>
            <div class="menu"></div>
          </div>
          <div class="ui huge selection dropdown" id="keys">
            <input type="hidden" name="project"></input>
            <i class="dropdown icon"></i>
            <div class="default text">Select a key</div>
            <div class="menu"></div>
          </div>
          <button id="get" class="ui big button">get</button>
        </div>
        <div class="row" id="change">
          <span class="label"></span>
          <span class="action">(Change project)</span>
        </div>
      </div>
    </div>

    <!-- END CONTAINER -->

    <div id="view"></div>

    <script type="x-shader/x-vertex" id="sphere-vs">
      void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    </script>

    <script type="x-shader/x-vertex" id="sphere-fs">
      uniform vec2 resolution;
      uniform float noise;
      float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}
      void main() {
        vec3 color = vec3( 34.0 / 255.0 );
        vec2 center = resolution * 0.5;
        float vignette = distance( center, gl_FragCoord.xy ) / resolution.x;
        vignette = 4.1 - vignette * 5.5;
        float n = noise * ( .5 - random( vec3( 1. ), length( gl_FragCoord ) ) );
        gl_FragColor = vec4( color * vec3( vignette ) + vec3( n ), 1. );
      }
    </script>
    <script type="x-shader/x-vertex" id="vertexShader">
      attribute vec4 tangent;
      uniform float time;
      uniform vec2 repeat;
      uniform float useNormal;
      uniform float useRim;
      varying vec2 vUv;
      varying vec3 vTangent;
      varying vec3 vBinormal;
      varying vec3 vNormal;
      varying vec3 vEye;
      varying vec3 vU;
      varying vec2 vN;
      void main() {
        vU = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) );
        if( useNormal == 0. ) {
          vec3 n = normalize( normalMatrix * normal );
          vec3 r = reflect( vU, n );
          float m = 2.0 * sqrt( r.x * r.x + r.y * r.y + ( r.z + 1.0 ) * ( r.z+1.0 ) );
          vN = vec2( r.x / m + 0.5,  r.y / m + 0.5 );
        } else {
          vN = vec2( 0. );
        }
        vUv = repeat * uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        vNormal = normalize( normalMatrix * normal );
        if( useNormal == 1. ) {
          vTangent = normalize( normalMatrix * tangent.xyz );
          vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );
        } else {
          vTangent = vec3( 0. );
          vBinormal = vec3( 0. );
        }
        if( useRim > 0. ) {
          vEye = ( modelViewMatrix * vec4( position, 1.0 ) ).xyz;
        } else {
          vEye = vec3( 0. );
        }
      }
    </script>
    <script type="x-shader/x-vertex" id="fragmentShader">
      uniform float time;
      uniform float bump;
      uniform sampler2D tNormal;
      uniform sampler2D tMatCap;
      uniform float noise;
      uniform float useNormal;
      uniform float useRim;
      uniform float rimPower;
      uniform float useScreen;
      uniform float normalScale;
      uniform float normalRepeat;
      varying vec2 vUv;
      varying vec3 vTangent;
      varying vec3 vBinormal;
      varying vec3 vNormal;
      varying vec3 vEye;
      varying vec3 vU;
      varying vec2 vN;
      float random(vec3 scale,float seed){return fract(sin(dot(gl_FragCoord.xyz+seed,scale))*43758.5453+seed);}
      void main() {
        vec3 finalNormal = vNormal;
        vec2 calculatedNormal = vN;
        if( useNormal == 1. ) {
          vec3 normalTex = texture2D( tNormal, vUv * normalRepeat ).xyz * 2.0 - 1.0;
          normalTex.xy *= normalScale;
          normalTex.y *= -1.;
          normalTex = normalize( normalTex );
          mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );
          finalNormal = tsb * normalTex;
          vec3 r = reflect( vU, normalize( finalNormal ) );
          float m = 2.0 * sqrt( r.x * r.x + r.y * r.y + ( r.z + 1.0 ) * ( r.z+1.0 ) );
          calculatedNormal = vec2( r.x / m + 0.5,  r.y / m + 0.5 );
        }
        vec3 base = texture2D( tMatCap, calculatedNormal ).rgb;
        // rim lighting
        if( useRim > 0. ) {
          float f = rimPower * abs( dot( vNormal, normalize( vEye ) ) );
          f = useRim * ( 1. - smoothstep( 0.0, 1., f ) );
              base += vec3( f );
        }
        // screen blending
        if( useScreen == 1. ) {
          base = vec3( 1. ) - ( vec3( 1. ) - base ) * ( vec3( 1. ) - base );
        }
        // noise 
        base += noise * ( .5 - random( vec3( 1. ), length( gl_FragCoord ) ) );
        gl_FragColor = vec4( base, 1. );
      }
    </script>
  </body>
</html>
